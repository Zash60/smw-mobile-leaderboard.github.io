<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMW Mobile Leaderboard</title>
    <style>
        :root { --bg-color: #121212; --text-color: #e0e0e0; --primary-color: #ffffff; --secondary-color: #b3b3b3; --border-color: #333333; --pending-color: #f39c12; --accent-color: #6200ee; --rejected-color: #e74c3c; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; margin: 0; padding: 1rem; }
        header { text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; margin-bottom: 1.5rem; }
        h1, h2, h3 { color: var(--primary-color); }
        nav { margin-top: 1rem; display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
        nav a, .action-button { color: var(--secondary-color); text-decoration: none; font-weight: bold; cursor: pointer; }
        nav a:hover, .action-button:hover { color: var(--primary-color); }
        main { max-width: 900px; margin: 0 auto; }
        .grid-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; }
        .card { background-color: #1e1e1e; border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; text-align: center; cursor: pointer; transition: transform 0.2s; }
        .card:hover { transform: translateY(-5px); }
        .table-container { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        .mod-actions { display: flex; gap: 5px; align-items: center; white-space: nowrap; }
        .mod-actions button { background: none; border: 1px solid var(--border-color); color: var(--text-color); cursor: pointer; padding: 4px 8px; border-radius: 4px; font-size: 1rem; line-height: 1; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
        .modal-content { background-color: #2a2a2a; padding: 2rem; border-radius: 8px; width: 90%; max-width: 500px; position: relative; max-height: 90vh; overflow-y: auto; }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 1.5rem; cursor: pointer; }
        form label { display: block; margin-top: 1rem; }
        form input, form select, form button { width: 100%; padding: 0.75rem; margin-top: 0.5rem; border-radius: 4px; border: 1px solid var(--border-color); background-color: #333; color: var(--text-color); box-sizing: border-box; }
        form button { background-color: var(--accent-color); font-weight: bold; cursor: pointer; }
        form button:disabled { background-color: #555; cursor: not-allowed; }
        .loader { text-align: center; font-size: 1.2em; padding: 2rem; }
        .breadcrumb { margin-bottom: 1rem; font-size: 1.1em; }
        .breadcrumb a { color: var(--secondary-color); }
        .breadcrumb span { color: var(--primary-color); }
        #mod-queue-container td { vertical-align: middle; }
        .wr-list { font-size: 0.9em; color: var(--secondary-color); list-style-type: none; padding-left: 0; }
        .error-message { color: var(--rejected-color); margin-top: 1rem; display: none; }

        @media (max-width: 600px) {
            body { padding: 0.5rem; }
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.3rem; }
            .card h3 { font-size: 1.1rem; }
            td, th { padding: 0.5rem; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Super Mario World Mobile Leaderboard</h1>
        <nav>
            <a href="#home">Categories</a>
            <a href="#worldrecords">World Records</a>
            <span id="mod-queue-link-container"></span>
        </nav>
        <div id="user-actions" style="margin-top: 1rem;">
            <a class="action-button" onclick="openSubmissionModal()">Submit Run</a>
            <span style="color: var(--border-color); margin: 0 10px;">|</span>
            <span id="moderator-auth-section"></span>
        </div>
    </header>
    <main id="app-container"></main>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { 
            getFirestore, collection, getDocs, doc, collectionGroup,
            query, where, orderBy, onSnapshot, addDoc, updateDoc, deleteDoc, writeBatch, getDoc
        } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
        import { 
            getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut 
        } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";

        // ==============================================================================
        // --- 1. CONFIG & APP STATE ---
        // ==============================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyBk2vOTjxk0MaWJVhDFALEEbE_v0IYsd-E",
            authDomain: "smw-mobile-leaderboard2.firebaseapp.com",
            projectId: "smw-mobile-leaderboard2",
            storageBucket: "smw-mobile-leaderboard2.firebasestorage.app",
            messagingSenderId: "924486924038",
            appId: "1:924486924038:web:737b0ae58fb20a91bc5087"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        const appContainer = document.getElementById('app-container');
        const appState = {
            isModerator: false,
            categoriesCache: [],
            subcategoriesCache: {},
            currentListener: null,
        };
        
        window.openSubmissionModal = openSubmissionModal;
        window.openEditModal = openEditModal;
        window.openLoginModal = openLoginModal;
        window.closeModal = closeModal;
        window.handleRunSubmission = handleRunSubmission;
        window.handleRunUpdate = handleRunUpdate;
        window.handleLogin = handleLogin;
        window.logoutModerator = logoutModerator;
        window.updateRunStatus = updateRunStatus;
        window.deleteRun = deleteRun;
        window.seedDatabase = seedDatabase;

        // ==============================================================================
        // --- 2. ROUTER & NAVIGATION ---
        // ==============================================================================
        function router() {
            if (appState.currentListener) {
                appState.currentListener();
                appState.currentListener = null;
            }

            const hash = window.location.hash || '#home';
            if (hash === '#home') {
                showCategoriesPage();
            } else if (hash.startsWith('#category/')) {
                const categoryId = hash.substring('#category/'.length);
                showSubcategoriesPage(categoryId);
            } else if (hash.startsWith('#leaderboard/')) {
                const [categoryId, subcategoryId] = hash.substring('#leaderboard/'.length).split('/');
                showLeaderboard(categoryId, subcategoryId);
            } else if (hash === '#modqueue') {
                showModQueuePage();
            } else if (hash === '#worldrecords') {
                showWorldRecordsPage();
            } else {
                window.location.hash = '#home';
            }
        }
        
        // ==============================================================================
        // --- 3. RENDER FUNCTIONS ---
        // ==============================================================================
        function renderLoader(message) { appContainer.innerHTML = `<div class="loader">${message}</div>`; }
        function renderError(message) { appContainer.innerHTML = `<h2>${message}</h2>`; }

        async function loadCategories() {
            if (appState.categoriesCache.length > 0) return appState.categoriesCache;
            try {
                const q = query(collection(db, "categories"), orderBy("order"));
                const snapshot = await getDocs(q);
                appState.categoriesCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                return appState.categoriesCache;
            } catch (error) { console.error(error); renderError("Error connecting to the database."); return []; }
        }

        async function loadSubcategories(categoryId) {
            if (appState.subcategoriesCache[categoryId]) return appState.subcategoriesCache[categoryId];
             try {
                const subcategoriesCol = collection(db, "categories", categoryId, "subcategories");
                const q = query(subcategoriesCol, orderBy("order"));
                const snapshot = await getDocs(q);
                const subcats = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                appState.subcategoriesCache[categoryId] = subcats;
                return subcats;
            } catch (error) { console.error(error); renderError("Could not load subcategories."); return []; }
        }
        
        async function showCategoriesPage() {
            renderLoader("Loading Categories...");
            const categories = await loadCategories();
            if (categories.length === 0) {
                renderError('No categories found. Please run `seedDatabase()` in the console (F12) to populate the initial structure.');
                return;
            }
            appContainer.innerHTML = `
                <h2>Select a Category</h2>
                <div class="grid-container">
                    ${categories.map(cat => `
                        <div class="card" onclick="window.location.hash='#category/${cat.id}'">
                            <h3>${cat.name}</h3>
                        </div>
                    `).join('')}
                </div>`;
        }
        
        async function showSubcategoriesPage(categoryId) {
            renderLoader("Loading Subcategories...");
            await loadCategories();
            const category = appState.categoriesCache.find(c => c.id === categoryId);
            if (!category) { window.location.hash = '#home'; return; }

            const subcategories = await loadSubcategories(categoryId);
            appContainer.innerHTML = `
                <div class="breadcrumb"><a href="#home">Categories</a> / <span>${category.name}</span></div>
                <h2>Select a Subcategory</h2>
                <div class="grid-container">
                    ${subcategories.map(sub => `
                        <div class="card" onclick="window.location.hash='#leaderboard/${category.id}/${sub.id}'">
                            <h3>${sub.name}</h3>
                        </div>
                    `).join('')}
                </div>`;
        }

        async function showLeaderboard(categoryId, subcategoryId) {
            renderLoader("Loading Leaderboard...");
            await loadCategories();
            await loadSubcategories(categoryId);
            const category = appState.categoriesCache.find(c => c.id === categoryId);
            const subcategory = appState.subcategoriesCache[categoryId]?.find(s => s.id === subcategoryId);

            if (!category || !subcategory) { window.location.hash = '#home'; return; }
            
            const runsCollectionRef = collection(db, 'categories', categoryId, 'subcategories', subcategoryId, 'runs');
            const q = query(runsCollectionRef, where('status', '==', 'verified'), orderBy('time_numeric'));

            appState.currentListener = onSnapshot(q, (snapshot) => {
                const runs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                appContainer.innerHTML = `
                    <div class="breadcrumb">
                        <a href="#home">Categories</a> / <a href="#category/${category.id}">${category.name}</a> / <span>${subcategory.name}</span>
                    </div>
                    <h2>${category.name} - ${subcategory.name}</h2>
                    <div class="table-container">
                        <table>
                            <thead><tr><th>#</th><th>Runner</th><th>Time</th><th>Date</th><th>Video</th>${appState.isModerator ? '<th>Actions</th>' : ''}</tr></thead>
                            <tbody>
                            ${runs.map((run, index) => {
                                const runDate = run.date ? new Date(run.date.replace(/-/g, '\/')).toLocaleDateString() : 'N/A';
                                return `<tr>
                                    <td>${index + 1}</td>
                                    <td>${run.runner}</td>
                                    <td>${run.time_str}</td>
                                    <td>${runDate}</td>
                                    <td><a href="${run.videoLink}" target="_blank" rel="noopener noreferrer">Link</a></td>
                                    ${appState.isModerator ? `
                                        <td><div class="mod-actions">
                                            <button onclick="openEditModal('${categoryId}', '${subcategoryId}', '${run.id}')" title="Edit">✏️</button>
                                            <button onclick="deleteRun('${categoryId}', '${subcategoryId}', '${run.id}')" title="Delete">🗑️</button>
                                        </div></td>` : ''}
                                </tr>`;
                            }).join('') || '<tr><td colspan="6">No verified runs submitted yet.</td></tr>'}
                            </tbody>
                        </table>
                    </div>`;
            }, error => {
                console.error("Error fetching leaderboard:", error);
                renderError("Failed to load leaderboard.");
            });
        }
        
        async function showModQueuePage() {
            if (!appState.isModerator) { window.location.hash = '#home'; return; }
            renderLoader("Loading Moderation Queue...");
            await loadCategories();

            try {
                const q = query(collectionGroup(db, 'runs'), where('status', '==', 'pending'));
                const pendingRunsSnapshot = await getDocs(q);
                const pendingRuns = [];
                for (const doc of pendingRunsSnapshot.docs) {
                    const path = doc.ref.path.split('/');
                    const runData = {
                        id: doc.id,
                        categoryId: path[1],
                        subcategoryId: path[3],
                        ...doc.data()
                    };
                    if (!appState.subcategoriesCache[runData.categoryId]) {
                        await loadSubcategories(runData.categoryId);
                    }
                    pendingRuns.push(runData);
                }

                appContainer.innerHTML = `
                    <h2>Moderation Queue</h2>
                    <div id="mod-queue-container" class="table-container">
                        <table>
                            <thead><tr><th>Runner</th><th>Category / Subcategory</th><th>Time</th><th>Date</th><th>Video</th><th>Actions</th></tr></thead>
                            <tbody>
                                ${pendingRuns.map(run => {
                                    const category = appState.categoriesCache.find(c => c.id === run.categoryId);
                                    const subcategory = appState.subcategoriesCache[run.categoryId]?.find(s => s.id === run.subcategoryId);
                                    const runDate = run.date ? new Date(run.date.replace(/-/g, '\/')).toLocaleDateString() : 'N/A';
                                    return `
                                        <tr>
                                            <td>${run.runner}</td>
                                            <td>${category?.name || '...'} / ${subcategory?.name || '...'}</td>
                                            <td>${run.time_str}</td>
                                            <td>${runDate}</td>
                                            <td><a href="${run.videoLink}" target="_blank">Link</a></td>
                                            <td><div class="mod-actions">
                                                <button onclick="updateRunStatus('${run.categoryId}', '${run.subcategoryId}', '${run.id}', 'verified')" title="Verify">✅</button>
                                                <button onclick="updateRunStatus('${run.categoryId}', '${run.subcategoryId}', '${run.id}', 'rejected')" title="Reject">❌</button>
                                                <button onclick="openEditModal('${run.categoryId}', '${run.subcategoryId}', '${run.id}')" title="Edit">✏️</button>
                                                <button onclick="deleteRun('${run.categoryId}', '${run.subcategoryId}', '${run.id}')" title="Delete">🗑️</button>
                                            </div></td>
                                        </tr>`;
                                }).join('') || '<tr><td colspan="6">The moderation queue is empty.</td></tr>'}
                            </tbody>
                        </table>
                    </div>`;
            } catch (error) {
                console.error("Error loading mod queue:", error);
                renderError("Failed to load moderation queue. You may need to create a Firestore index. Check the console (F12) for an error message with a link to create it.");
            }
        }
        
        async function showWorldRecordsPage() {
            renderLoader("Calculating World Records...");
            try {
                await loadCategories();
                const q = query(collectionGroup(db, 'runs'), where('status', '==', 'verified'));
                const allRunsSnapshot = await getDocs(q);
                
                const subcats = {};
                for(const doc of allRunsSnapshot.docs){
                    const run = doc.data();
                    const path = doc.ref.path.split('/');
                    const key = `${path[1]}/${path[3]}`;
                    if (!subcats[key]) subcats[key] = { runs: [], categoryId: path[1], subcategoryId: path[3] };
                    subcats[key].runs.push(run);
                }

                const wrData = {};
                for (const key in subcats) {
                    const subcatInfo = subcats[key];
                    if (subcatInfo.runs.length > 0) {
                        subcatInfo.runs.sort((a, b) => a.time_numeric - b.time_numeric);
                        const originalRunnerName = subcatInfo.runs[0].runner;
                        const normalizedKey = originalRunnerName.toLowerCase().trim();

                        if (!appState.subcategoriesCache[subcatInfo.categoryId]) {
                           await loadSubcategories(subcatInfo.categoryId);
                        }
                        const category = appState.categoriesCache.find(c => c.id === subcatInfo.categoryId);
                        const subcategory = appState.subcategoriesCache[subcatInfo.categoryId]?.find(s => s.id === subcatInfo.subcategoryId);
                        const wrTitle = `${category?.name || ''} - ${subcategory?.name || ''}`;

                        if (!wrData[normalizedKey]) {
                            wrData[normalizedKey] = { displayName: originalRunnerName, count: 0, titles: [] };
                        }
                        wrData[normalizedKey].count++;
                        wrData[normalizedKey].titles.push(wrTitle);
                    }
                }

                const sortedWRs = Object.values(wrData).sort((a, b) => b.count - a.count);

                appContainer.innerHTML = `
                    <h2>World Records Tally</h2>
                    <div class="table-container">
                        <table>
                            <thead><tr><th>#</th><th>Runner</th><th>WRs</th><th>Categories</th></tr></thead>
                            <tbody>
                                ${sortedWRs.map((data, index) => `
                                    <tr>
                                        <td>${index + 1}</td>
                                        <td>${data.displayName}</td>
                                        <td>${data.count}</td>
                                        <td><ul class="wr-list">${data.titles.sort().map(s => `<li>${s}</li>`).join('')}</ul></td>
                                    </tr>
                                `).join('') || '<tr><td colspan="4">No world records found.</td></tr>'}
                            </tbody>
                        </table>
                    </div>
                `;
            } catch (error) {
                console.error("Error calculating world records:", error);
                renderError("Failed to calculate world records. You may need to create an index. Check the console (F12) for a link.");
            }
        }
        
        // ==============================================================================
        // --- 4. ACTIONS & MODERATION ---
        // ==============================================================================
        function updateModeratorUI(user) {
            appState.isModerator = !!user;
            const modSection = document.getElementById('moderator-auth-section');
            const modQueueLink = document.getElementById('mod-queue-link-container');

            if (user) {
                modSection.innerHTML = `<a class="action-button" onclick="logoutModerator()">Logout (${user.email})</a>`;
                modQueueLink.innerHTML = `<a href="#modqueue">Moderation Queue</a>`;
            } else {
                modSection.innerHTML = `<a class="action-button" onclick="openLoginModal()">Moderator Login</a>`;
                modQueueLink.innerHTML = '';
            }
            router();
        }

        onAuthStateChanged(auth, user => { updateModeratorUI(user); });

        async function handleLogin(event) {
            event.preventDefault();
            const form = event.target;
            const email = form.email.value;
            const password = form.password.value;
            const errorElement = document.getElementById('login-error');
            errorElement.style.display = 'none';
            try {
                await signInWithEmailAndPassword(auth, email, password);
                closeModal('login-modal');
            } catch (error) {
                console.error("Login failed:", error.message);
                errorElement.textContent = "Login failed. Please check your email and password.";
                errorElement.style.display = 'block';
            }
        }
        
        async function logoutModerator() { await signOut(auth); }

        function openModal(modalId) { document.getElementById(modalId).style.display = 'flex'; }
        function closeModal(modalId) { document.getElementById(modalId).style.display = 'none'; }
        function openLoginModal() { openModal('login-modal'); }
        
        async function openSubmissionModal() {
            const categories = await loadCategories();
            const catSelect = document.getElementById('category-select');
            const subcatSelect = document.getElementById('subcategory-select');
            
            catSelect.innerHTML = '<option value="">-- Select a Category --</option>' + categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
            subcatSelect.innerHTML = '<option value="">-- Select Category First --</option>';
            subcatSelect.disabled = true;

            catSelect.onchange = async () => {
                const categoryId = catSelect.value;
                if (!categoryId) {
                    subcatSelect.innerHTML = '<option value="">-- Select Category First --</option>';
                    subcatSelect.disabled = true;
                    return;
                }
                const subcategories = await loadSubcategories(categoryId);
                subcatSelect.innerHTML = '<option value="">-- Select a Subcategory --</option>' + subcategories.map(s => `<option value="${s.id}">${s.name}</option>`).join('');
                subcatSelect.disabled = false;
            };
            
            openModal('submission-modal');
        }

        async function openEditModal(categoryId, subcategoryId, runId) {
            if (!appState.isModerator) return;
            try {
                const runRef = doc(db, 'categories', categoryId, 'subcategories', subcategoryId, 'runs', runId);
                const runDoc = await getDoc(runRef);
                if (!runDoc.exists()) { alert("Run not found!"); return; }
                const runData = runDoc.data();
                
                document.getElementById('edit-run-id').value = runId;
                document.getElementById('edit-category-id').value = categoryId;
                document.getElementById('edit-subcategory-id').value = subcategoryId;
                document.getElementById('edit-runner').value = runData.runner;
                document.getElementById('edit-time').value = runData.time_str;
                document.getElementById('edit-date').value = runData.date;
                document.getElementById('edit-videoLink').value = runData.videoLink;
                
                openModal('edit-run-modal');
            } catch(error) {
                console.error("Error opening edit modal:", error);
                alert("Could not load run data for editing.");
            }
        }

        function parseTimeToNumeric(timeStr) {
            if (String(timeStr).includes(':')) {
                const parts = String(timeStr).split(':').map(Number);
                if (parts.length === 2) return (parts[0] * 60) + parts[1];
                if (parts.length === 3) return (parts[0] * 3600) + (parts[1] * 60) + parts[2];
            }
            return parseFloat(timeStr) || Infinity;
        }

        async function handleRunSubmission(event) {
            event.preventDefault();
            const form = document.getElementById('submission-form');
            const submitButton = document.getElementById('submit-run-button');
            submitButton.disabled = true;
            submitButton.textContent = 'Submitting...';

            const categoryId = form['category-select'].value;
            const subcategoryId = form['subcategory-select'].value;
            const runnerName = form.runner.value.trim();
            const timeStr = form.time.value;
            
            const runData = {
                runner: runnerName,
                runner_normalized: runnerName.toLowerCase().trim(),
                time_str: timeStr,
                time_numeric: parseTimeToNumeric(timeStr),
                date: form.date.value,
                videoLink: form.videoLink.value,
                status: 'pending'
            };

            const runsRef = collection(db, 'categories', categoryId, 'subcategories', subcategoryId, 'runs');
            
            try {
                const q = query(runsRef, where('runner_normalized', '==', runData.runner_normalized), where('status', '==', 'verified'));
                const existingRunSnapshot = await getDocs(q);

                if (!existingRunSnapshot.empty) {
                    const existingTime = existingRunSnapshot.docs[0].data().time_numeric;
                    if (runData.time_numeric >= existingTime) {
                        alert("Submission failed: Your new time must be faster than your currently verified record.");
                        submitButton.disabled = false;
                        submitButton.textContent = 'Submit Run';
                        return;
                    }
                }
                
                await addDoc(runsRef, runData);
                alert("Run submitted for moderation!");
                closeModal('submission-modal');
                form.reset();
            } catch (error) {
                alert("An error occurred during submission.");
                console.error("Run submission error:", error);
            } finally {
                submitButton.disabled = false;
                submitButton.textContent = 'Submit Run';
            }
        }

        async function handleRunUpdate(event) {
            event.preventDefault();
            if (!appState.isModerator) return;
            const form = event.target;
            const button = form.querySelector('button');
            button.disabled = true;
            button.textContent = 'Updating...';

            const runId = form['edit-run-id'].value;
            const categoryId = form['edit-category-id'].value;
            const subcategoryId = form['edit-subcategory-id'].value;
            const runnerName = form['edit-runner'].value;
            const timeStr = form['edit-time'].value;
            
            const updatedData = {
                runner: runnerName,
                runner_normalized: runnerName.toLowerCase().trim(),
                time_str: timeStr,
                time_numeric: parseTimeToNumeric(timeStr),
                date: form['edit-date'].value,
                videoLink: form['edit-videoLink'].value
            };

            try {
                const runRef = doc(db, 'categories', categoryId, 'subcategories', subcategoryId, 'runs', runId);
                await updateDoc(runRef, updatedData);
                alert("Run updated successfully!");
                closeModal('edit-run-modal');
                router();
            } catch(error) {
                console.error("Run update error:", error);
                alert("Failed to update run.");
            } finally {
                button.disabled = false;
                button.textContent = 'Update Run';
            }
        }

        async function updateRunStatus(categoryId, subcategoryId, runId, newStatus) {
            if (!appState.isModerator) return;
            if (!confirm(`Are you sure you want to ${newStatus} this run?`)) return;

            const runRef = doc(db, 'categories', categoryId, 'subcategories', subcategoryId, 'runs', runId);
            try {
                if (newStatus === 'verified') {
                    const runDoc = await getDoc(runRef);
                    if (!runDoc.exists()) throw new Error("Run not found");
                    const runData = runDoc.data();
                    
                    const runsCollectionRef = collection(db, 'categories', categoryId, 'subcategories', subcategoryId, 'runs');
                    const q = query(runsCollectionRef, where('runner_normalized', '==', runData.runner_normalized), where('status', '==', 'verified'));
                    const oldRunsSnapshot = await getDocs(q);
                    
                    const batch = writeBatch(db);
                    oldRunsSnapshot.forEach(doc => {
                        console.log(`Deleting old verified run ${doc.id} for runner ${runData.runner}`);
                        batch.delete(doc.ref);
                    });
                    
                    batch.update(runRef, { status: 'verified' });
                    await batch.commit();

                } else {
                    await updateDoc(runRef, { status: newStatus });
                }
                alert(`Run has been ${newStatus}.`);
                router();
            } catch (error) {
                console.error(`Failed to ${newStatus} run:`, error);
                alert(`An error occurred.`);
            }
        }

        async function deleteRun(categoryId, subcategoryId, runId) {
            if (!appState.isModerator) return;
            if (!confirm("Are you sure you want to permanently delete this run? This cannot be undone.")) return;
            try {
                const runRef = doc(db, 'categories', categoryId, 'subcategories', subcategoryId, 'runs', runId);
                await deleteDoc(runRef);
                alert("Run deleted successfully.");
                router();
            } catch (error) {
                console.error("Failed to delete run:", error);
                alert("An error occurred while deleting the run.");
            }
        }
        
        // ==============================================================================
        // --- 5. SEED FUNCTION (FOR DEV CONSOLE USE) ---
        // ==============================================================================
        async function seedDatabase() {
            console.log("This will POPULATE the 'categories' collection. It is critical that you MANUALLY delete the collection in the Firebase Console first for a clean seed.");
            if (!confirm("This will overwrite existing data. Are you sure you want to continue?")) return;

            const seedData = {
                categories: [
                    { id: "96-exit", name: "96 Exit", order: 1, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "all-castles", name: "All Castles", order: 2, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "no-starworld", name: "No Starworld", order: 3, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "11-exit", name: "11 Exit", order: 4, subcategories: [ 
                        { id: "cloud", name: "Cloud", order: 1, runs: [] },
                        { id: "orb", name: "Orb", order: 2, runs: [] },
                        { id: "glitchless", name: "Glitchless", order: 3, runs: [] },
                    ]},
                    { id: "0-exit", name: "0 Exit", order: 5, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "95-exit-no-cape", name: "95 Exit, No Cape", order: 6, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "all-castles-no-cape", name: "All Castles, No Cape", order: 7, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "no-cape-no-starworld", name: "No Cape, No Starworld", order: 8, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "11-exit-no-cape", name: "11 Exit, No Cape", order: 9, subcategories: [ 
                        { id: "cloud", name: "Cloud", order: 1, runs: [] },
                        { id: "orb", name: "Orb", order: 2, runs: [] },
                        { id: "glitchless", name: "Glitchless", order: 3, runs: [] },
                    ]},
                    { id: "all-castles-small-only", name: "All Castles, Small Only", order: 10, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "no-starworld-small-only", name: "No Starworld, Small Only", order: 11, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "small-only", name: "Small Only", order: 12, subcategories: [ {id: "any", name: "Any%", order: 1, runs: []} ]},
                    { id: "lunar-dragon", name: "Lunar Dragon", order: 13, subcategories: [ 
                        { id: "glitchless", name: "Glitchless", order: 1, runs: [] },
                        { id: "glitches", name: "Glitches", order: 2, runs: [] },
                    ]},
                ]
            };
            
            try {
                console.log("Starting database seed...");
                const batch = writeBatch(db);
                const categoriesCollection = collection(db, 'categories');
                
                for (const category of seedData.categories) {
                    const categoryRef = doc(categoriesCollection, category.id);
                    batch.set(categoryRef, { name: category.name, order: category.order });
                    for (const subcategory of category.subcategories) {
                        const subcategoryRef = doc(categoryRef, 'subcategories', subcategory.id);
                        batch.set(subcategoryRef, { name: subcategory.name, order: subcategory.order });
                    }
                }
                await batch.commit();
                console.log("DATABASE SEEDING COMPLETE!");
                window.location.reload();
            } catch (error) {
                console.error("SEEDING FAILED:", error);
                alert("Seeding failed. Check the console for details. Make sure the 'categories' collection was manually deleted from Firebase first.");
            }
        }
        
        // ==============================================================================
        // --- 6. INITIALIZATION ---
        // ==============================================================================
        window.addEventListener('hashchange', router);
        document.addEventListener('DOMContentLoaded', () => {
            document.body.insertAdjacentHTML('beforeend', `
                <div id="submission-modal" class="modal">
                    <div class="modal-content">
                        <span class="close-btn" onclick="closeModal('submission-modal')">&times;</span>
                        <h2>Submit New Run</h2>
                        <form id="submission-form" onsubmit="handleRunSubmission(event)">
                            <label for="category-select">Category:</label><select id="category-select" required></select>
                            <label for="subcategory-select">Subcategory:</label><select id="subcategory-select" required disabled></select>
                            <label for="runner">Runner:</label><input type="text" id="runner" required>
                            <label for="time">Time (e.g., 48:15 or 1:23:45):</label><input type="text" id="time" required>
                            <label for="date">Date:</label><input type="date" id="date" required>
                            <label for="videoLink">Video Link:</label><input type="url" id="videoLink" required>
                            <button type="submit" id="submit-run-button">Submit Run</button>
                        </form>
                    </div>
                </div>
                <div id="edit-run-modal" class="modal">
                    <div class="modal-content">
                        <span class="close-btn" onclick="closeModal('edit-run-modal')">&times;</span>
                        <h2>Edit Run</h2>
                        <form id="edit-run-form" onsubmit="handleRunUpdate(event)">
                            <input type="hidden" id="edit-run-id"><input type="hidden" id="edit-category-id"><input type="hidden" id="edit-subcategory-id">
                            <label for="edit-runner">Runner:</label><input type="text" id="edit-runner" required>
                            <label for="edit-time">Time:</label><input type="text" id="edit-time" required>
                            <label for="edit-date">Date:</label><input type="date" id="edit-date" required>
                            <label for="edit-videoLink">Video Link:</label><input type="url" id="edit-videoLink" required>
                            <button type="submit" id="update-run-button">Update Run</button>
                        </form>
                    </div>
                </div>
                 <div id="login-modal" class="modal">
                    <div class="modal-content">
                        <span class="close-btn" onclick="closeModal('login-modal')">&times;</span>
                        <h2>Moderator Login</h2>
                        <form id="login-form" onsubmit="handleLogin(event)">
                            <label for="email">Email:</label>
                            <input type="email" id="email" required>
                            <label for="password">Password:</label>
                            <input type="password" id="password" required>
                            <button type="submit">Log In</button>
                            <p id="login-error" class="error-message"></p>
                        </form>
                    </div>
                </div>
            `);

            onAuthStateChanged(auth, user => {
                updateModeratorUI(user);
            });
            
            router();
        });
    </script>
</body>
</html>
