<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMW Mobile Speedrun Leaderboard</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #f0f0f0;
            --primary-color: #4CAF50; /* Green */
            --secondary-color: #FFEB3B; /* Yellow */
            --border-color: #444;
            --accent-color: #2196F3; /* Blue */
            --pending-color: #FF9800; /* Orange */
            --rejected-color: #f44336; /* Red */
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 1rem;
        }
        header { text-align: center; border-bottom: 2px solid var(--primary-color); padding-bottom: 1rem; margin-bottom: 1.5rem; }
        h1, h2, h3 { color: var(--secondary-color); text-shadow: 1px 1px 2px #000; }
        nav { margin-top: 1rem; display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
        nav a, .action-button { color: var(--text-color); text-decoration: none; font-weight: bold; cursor: pointer; padding: 8px 12px; border-radius: 4px; transition: background-color 0.2s; }
        nav a:hover, .action-button:hover { background-color: var(--primary-color); color: var(--bg-color); }
        main { max-width: 900px; margin: 0 auto; }
        .grid-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; }
        .card { background-color: #2a2a2a; border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; text-align: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .card:hover { transform: translateY(-5px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .table-container { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        .mod-actions { display: flex; gap: 5px; align-items: center; white-space: nowrap; }
        .mod-actions button { background: none; border: 1px solid var(--border-color); color: var(--text-color); cursor: pointer; padding: 4px 8px; border-radius: 4px; font-size: 1rem; line-height: 1; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
        .modal-content { background-color: #333; padding: 2rem; border-radius: 8px; width: 90%; max-width: 500px; position: relative; max-height: 90vh; overflow-y: auto; }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 1.5rem; cursor: pointer; }
        form label { display: block; margin-top: 1rem; }
        form input, form select, form button { width: 100%; padding: 0.75rem; margin-top: 0.5rem; border-radius: 4px; border: 1px solid var(--border-color); background-color: #444; color: var(--text-color); box-sizing: border-box; }
        form button { background-color: var(--accent-color); font-weight: bold; cursor: pointer; }
        form button:disabled { background-color: #555; cursor: not-allowed; }
        .loader { text-align: center; font-size: 1.2em; padding: 2rem; color: var(--secondary-color); }
        .breadcrumb { margin-bottom: 1rem; font-size: 1.1em; }
        .breadcrumb a { color: var(--primary-color); }
        .breadcrumb span { color: var(--text-color); }
        .error-message { color: var(--rejected-color); margin-top: 1rem; display: none; }

        @media (max-width: 600px) {
            body { padding: 0.5rem; }
            h1 { font-size: 1.5rem; }
            .card h3 { font-size: 1.1rem; }
        }
    </style>
</head>
<body>
    <header>
        <h1>SMW Mobile Speedrun Leaderboard</h1>
        <nav>
            <a href="#home">Categories</a>
            <a href="#worldrecords">World Records</a>
            <span id="mod-queue-link-container"></span>
        </nav>
        <div id="user-actions" style="margin-top: 1rem;">
            <a class="action-button" onclick="window.openSubmissionModal()">Submit Run</a>
            <span style="color: #555; margin: 0 10px;">|</span>
            <span id="moderator-auth-section"></span>
        </div>
    </header>
    <main id="app-container"></main>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, collection, getDocs, doc, getDoc, collectionGroup, query, where, orderBy, onSnapshot, writeBatch, addDoc, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDepZjZreEE-J_BbKPZzIU9bNmc1-Z1EpU",
            authDomain: "smw-mobile-leaderboard.firebaseapp.com",
            projectId: "smw-mobile-leaderboard",
            storageBucket: "smw-mobile-leaderboard.firebasestorage.app",
            messagingSenderId: "630687938724",
            appId: "1:630687938724:web:90bd99d54d951625264e31"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        const appState = {
            isModerator: false,
            categoriesCache: [],
            subcategoriesCache: {}, // { categoryId: [subcategories] }
            currentListener: null,
        };

        function router() {
            if (appState.currentListener) {
                appState.currentListener();
                appState.currentListener = null;
            }

            const hash = window.location.hash || '#home';
            if (hash === '#home') {
                showCategoriesPage();
            } else if (hash.startsWith('#category/')) {
                const categoryId = hash.substring('#category/'.length);
                showSubcategoriesPage(categoryId);
            } else if (hash.startsWith('#subcategory/')) {
                const [categoryId, subcategoryId] = hash.substring('#subcategory/'.length).split('/');
                showLeaderboard(categoryId, subcategoryId);
            } else if (hash === '#modqueue') {
                showModQueuePage();
            } else if (hash === '#worldrecords') {
                showWorldRecordsPage();
            } else {
                window.location.hash = '#home';
            }
        }
        
        function renderLoader(message) { appContainer.innerHTML = `<div class="loader">${message}</div>`; }
        function renderError(message) { appContainer.innerHTML = `<h2>${message}</h2>`; }

        async function loadCategories() {
            if (appState.categoriesCache.length > 0) return appState.categoriesCache;
            try {
                const q = query(collection(db, 'categories'), orderBy('order'));
                const snapshot = await getDocs(q);
                appState.categoriesCache = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                return appState.categoriesCache;
            } catch (error) { console.error(error); renderError("Error connecting to the database."); return []; }
        }

        async function loadSubcategories(categoryId) {
            if (appState.subcategoriesCache[categoryId]) return appState.subcategoriesCache[categoryId];
            try {
                const q = query(collection(db, `categories/${categoryId}/subcategories`), orderBy('order'));
                const snapshot = await getDocs(q);
                const subcategories = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                appState.subcategoriesCache[categoryId] = subcategories;
                return subcategories;
            } catch (error) { console.error(error); return []; }
        }
        
        async function showCategoriesPage() {
            renderLoader("Loading Categories...");
            const categories = await loadCategories();
            if (categories.length === 0) {
                renderError('No categories found. Please MANUALLY DELETE the `categories` collection in Firebase and run `seedDatabase()` in the console (F12).');
                return;
            }
            appContainer.innerHTML = `
                <h2>Select a Category</h2>
                <div class="grid-container">
                    ${categories.map(cat => `<div class="card" onclick="window.location.hash='#category/${cat.id}'"><h3>${cat.name}</h3></div>`).join('')}
                </div>`;
        }

        async function showSubcategoriesPage(categoryId) {
            renderLoader("Loading...");
            await loadCategories(); // Ensure cache is warm
            const category = appState.categoriesCache.find(c => c.id === categoryId);
            if (!category) { window.location.hash = '#home'; return; }

            const subcategories = await loadSubcategories(categoryId);
            // If a category has no subcategories, go directly to its "default" leaderboard.
            if (!subcategories || subcategories.length === 0) {
                window.location.hash = `#subcategory/${categoryId}/default`;
                return;
            }

            appContainer.innerHTML = `
                <div class="breadcrumb"><a href="#home">Categories</a> / <span>${category.name}</span></div>
                <h2>Select a Sub-category</h2>
                <div class="grid-container">
                    ${subcategories.map(sub => `<div class="card" onclick="window.location.hash='#subcategory/${categoryId}/${sub.id}'"><h3>${sub.name}</h3></div>`).join('')}
                </div>`;
        }
        
        async function showLeaderboard(categoryId, subcategoryId) {
            renderLoader("Loading Leaderboard...");
            await loadCategories();
            await loadSubcategories(categoryId);

            const category = appState.categoriesCache.find(c => c.id === categoryId);
            const subcategory = appState.subcategoriesCache[categoryId]?.find(s => s.id === subcategoryId);
            
            // Handle categories with no explicit subcategories (like "96 Exit")
            const isDefaultSubcategory = subcategoryId === 'default' && (!appState.subcategoriesCache[categoryId] || appState.subcategoriesCache[categoryId].length === 0);
            const leaderboardName = isDefaultSubcategory ? category.name : `${category.name}, ${subcategory.name}`;

            if (!category) { window.location.hash = '#home'; return; }
            if (!subcategory && !isDefaultSubcategory) { window.location.hash = `#category/${categoryId}`; return; }
            
            const runsCollectionRef = collection(db, `categories/${categoryId}/subcategories/${subcategoryId}/runs`);
            const q = query(runsCollectionRef, where('status', '==', 'verified'), orderBy('time_numeric'));

            appState.currentListener = onSnapshot(q, (snapshot) => {
                const runs = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                let breadcrumbHtml = `<a href="#home">Categories</a> / `;
                if (subcategory) { // If there are subcategories, link back to them
                    breadcrumbHtml += `<a href="#category/${categoryId}">${category.name}</a> / <span>${subcategory.name}</span>`;
                } else { // If no subcategories, this is the final page
                    breadcrumbHtml += `<span>${category.name}</span>`;
                }

                appContainer.innerHTML = `
                    <div class="breadcrumb">${breadcrumbHtml}</div>
                    <h2>${leaderboardName} Leaderboard</h2>
                    <div class="table-container">
                        <table>
                            <thead><tr><th>#</th><th>Runner</th><th>Time</th><th>Date</th><th>Video</th>${appState.isModerator ? '<th>Actions</th>' : ''}</tr></thead>
                            <tbody>
                            ${runs.map((run, index) => {
                                const runDate = run.date ? new Date(run.date.replace(/-/g, '\/')).toLocaleDateString() : 'N/A';
                                return `<tr>
                                    <td>${index + 1}</td>
                                    <td>${run.runner}</td>
                                    <td>${run.time_str}</td>
                                    <td>${runDate}</td>
                                    <td><a href="${run.videoLink}" target="_blank" rel="noopener noreferrer">Link</a></td>
                                    ${appState.isModerator ? `
                                        <td><div class="mod-actions">
                                            <button onclick="window.openEditModal('${categoryId}', '${subcategoryId}', '${run.id}')" title="Edit">‚úèÔ∏è</button>
                                            <button onclick="window.deleteRun('${categoryId}', '${subcategoryId}', '${run.id}')" title="Delete">üóëÔ∏è</button>
                                        </div></td>` : ''}
                                </tr>`;
                            }).join('') || '<tr><td colspan="6">No verified runs submitted yet.</td></tr>'}
                            </tbody>
                        </table>
                    </div>`;
            }, error => {
                console.error("Error fetching leaderboard:", error);
                renderError("Failed to load leaderboard.");
            });
        }
        
        async function showModQueuePage() { /* ... */ }
        async function showWorldRecordsPage() { /* ... */ }
        
        // ... (resto do c√≥digo JS da √∫ltima resposta, com pequenas adapta√ß√µes para sub-categorias)
        // O c√≥digo completo est√° abaixo para conveni√™ncia.
        function updateModeratorUI(user) {
            appState.isModerator = !!user;
            const modSection = document.getElementById('moderator-auth-section');
            const modQueueLink = document.getElementById('mod-queue-link-container');

            if (user) {
                modSection.innerHTML = `<a class="action-button" onclick="window.logoutModerator()">Logout (${user.email})</a>`;
                modQueueLink.innerHTML = `<a href="#modqueue">Moderation Queue</a>`;
            } else {
                modSection.innerHTML = `<a class="action-button" onclick="window.openLoginModal()">Moderator Login</a>`;
                modQueueLink.innerHTML = '';
            }
            router();
        }

        onAuthStateChanged(auth, user => {
            updateModeratorUI(user);
        });

        async function handleLogin(event) {
            event.preventDefault();
            const form = event.target;
            const errorElement = document.getElementById('login-error');
            errorElement.style.display = 'none';
            try {
                await signInWithEmailAndPassword(auth, form.email.value, form.password.value);
                closeModal('login-modal');
            } catch (error) {
                console.error("Login failed:", error.message);
                errorElement.textContent = "Login failed. Please check your email and password.";
                errorElement.style.display = 'block';
            }
        }
        
        async function logoutModerator() { await signOut(auth); }

        function openModal(modalId) { document.getElementById(modalId).style.display = 'flex'; }
        function closeModal(modalId) { document.getElementById(modalId).style.display = 'none'; }
        function openLoginModal() { openModal('login-modal'); }
        
        async function openSubmissionModal() {
            await loadCategories();
            const categorySelect = document.getElementById('category-select');
            const subcategorySelect = document.getElementById('subcategory-select');
            
            categorySelect.innerHTML = '<option value="">-- Select a Category --</option>' + appState.categoriesCache.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
            subcategorySelect.innerHTML = '<option value="">-- Select Category First --</option>';
            subcategorySelect.disabled = true;

            categorySelect.onchange = async () => {
                const categoryId = categorySelect.value;
                subcategorySelect.innerHTML = '<option value="">Loading...</option>';
                if (!categoryId) {
                    subcategorySelect.innerHTML = '<option value="">-- Select Category First --</option>';
                    subcategorySelect.disabled = true;
                    return;
                }
                const subcategories = await loadSubcategories(categoryId);
                if(subcategories.length > 0) {
                    subcategorySelect.innerHTML = '<option value="">-- Select Sub-category --</option>' + subcategories.map(s => `<option value="${s.id}">${s.name}</option>`).join('');
                    subcategorySelect.disabled = false;
                    document.getElementById('subcategory-group').style.display = 'block';
                } else {
                    subcategorySelect.innerHTML = `<option value="default">Default</option>`;
                    subcategorySelect.disabled = true;
                    document.getElementById('subcategory-group').style.display = 'none';
                }
            };
            openModal('submission-modal');
        }

        async function openEditModal(categoryId, subcategoryId, runId) {
            if (!appState.isModerator) return;
            try {
                const runRef = doc(db, `categories/${categoryId}/subcategories/${subcategoryId}/runs`, runId);
                const runDoc = await getDoc(runRef);
                if (!runDoc.exists()) { alert("Run not found!"); return; }
                const runData = runDoc.data();
                
                document.getElementById('edit-run-id').value = runId;
                document.getElementById('edit-category-id').value = categoryId;
                document.getElementById('edit-subcategory-id').value = subcategoryId;
                document.getElementById('edit-runner').value = runData.runner;
                document.getElementById('edit-time').value = runData.time_str;
                document.getElementById('edit-date').value = runData.date;
                document.getElementById('edit-videoLink').value = runData.videoLink;
                
                openModal('edit-run-modal');
            } catch(error) {
                console.error("Error opening edit modal:", error);
                alert("Could not load run data for editing.");
            }
        }

        function parseTimeToNumeric(timeStr) {
            if (String(timeStr).includes(':')) {
                const parts = String(timeStr).split(':').map(Number);
                let seconds = 0;
                if (parts.length === 3) seconds += parts[0] * 3600 + parts[1] * 60 + parts[2];
                else if (parts.length === 2) seconds += parts[0] * 60 + parts[1];
                return seconds;
            }
            return parseFloat(timeStr) || Infinity;
        }

        async function handleRunSubmission(event) {
            event.preventDefault();
            const form = document.getElementById('submission-form');
            const submitButton = document.getElementById('submit-run-button');
            submitButton.disabled = true;
            submitButton.textContent = 'Submitting...';

            const categoryId = form['category-select'].value;
            const subcategoryId = form['subcategory-select'].value;
            const runnerName = form.runner.value.trim();
            const timeStr = form.time.value;
            
            const runData = {
                runner: runnerName,
                runner_normalized: runnerName.toLowerCase().trim(),
                time_str: timeStr,
                time_numeric: parseTimeToNumeric(timeStr),
                date: form.date.value,
                videoLink: form.videoLink.value,
                status: 'pending'
            };
            
            const runsRef = collection(db, `categories/${categoryId}/subcategories/${subcategoryId}/runs`);
            
            try {
                const q = query(runsRef, where('runner_normalized', '==', runData.runner_normalized), where('status', '==', 'verified'));
                const existingRunSnapshot = await getDocs(q);

                if (!existingRunSnapshot.empty) {
                    const existingTime = existingRunSnapshot.docs[0].data().time_numeric;
                    if (runData.time_numeric >= existingTime) {
                        alert("Submission failed: Your new time must be faster than your currently verified record.");
                        submitButton.disabled = false;
                        submitButton.textContent = 'Submit Run';
                        return;
                    }
                }
                
                await addDoc(runsRef, runData);
                alert("Run submitted for moderation!");
                closeModal('submission-modal');
                form.reset();
            } catch (error) {
                alert("An error occurred during submission.");
                console.error("Run submission error:", error);
            } finally {
                submitButton.disabled = false;
                submitButton.textContent = 'Submit Run';
            }
        }

        async function handleRunUpdate(event) {
            event.preventDefault();
            if (!appState.isModerator) return;
            const form = event.target;
            const button = form.querySelector('button');
            button.disabled = true;
            button.textContent = 'Updating...';

            const runId = form['edit-run-id'].value;
            const categoryId = form['edit-category-id'].value;
            const subcategoryId = form['edit-subcategory-id'].value;
            const runnerName = form['edit-runner'].value;
            const timeStr = form['edit-time'].value;
            
            const updatedData = {
                runner: runnerName,
                runner_normalized: runnerName.toLowerCase().trim(),
                time_str: timeStr,
                time_numeric: parseTimeToNumeric(timeStr),
                date: form['edit-date'].value,
                videoLink: form['edit-videoLink'].value
            };

            try {
                const runRef = doc(db, `categories/${categoryId}/subcategories/${subcategoryId}/runs`, runId);
                await updateDoc(runRef, updatedData);
                alert("Run updated successfully!");
                closeModal('edit-run-modal');
                router();
            } catch(error) {
                console.error("Run update error:", error);
                alert("Failed to update run.");
            } finally {
                button.disabled = false;
                button.textContent = 'Update Run';
            }
        }
        
        async function updateRunStatus(categoryId, subcategoryId, runId, newStatus) {
            if (!appState.isModerator) return;
            if (!confirm(`Are you sure you want to ${newStatus} this run?`)) return;

            const runRef = doc(db, `categories/${categoryId}/subcategories/${subcategoryId}/runs`, runId);

            try {
                if (newStatus === 'verified') {
                    const runDoc = await getDoc(runRef);
                    if (!runDoc.exists()) throw new Error("Run not found");
                    const runData = runDoc.data();

                    const q = query(collection(db, `categories/${categoryId}/subcategories/${subcategoryId}/runs`),
                        where('runner_normalized', '==', runData.runner_normalized),
                        where('status', '==', 'verified'));
                    
                    const oldRunsSnapshot = await getDocs(q);
                    
                    const batch = writeBatch(db);
                    oldRunsSnapshot.forEach(d => { batch.delete(d.ref); });
                    batch.update(runRef, { status: 'verified' });
                    await batch.commit();
                } else {
                    await updateDoc(runRef, { status: newStatus });
                }
                alert(`Run has been ${newStatus}.`);
                router();
            } catch (error) {
                console.error(`Failed to ${newStatus} run:`, error);
                alert(`An error occurred.`);
            }
        }

        async function deleteRun(categoryId, subcategoryId, runId) {
            if (!appState.isModerator) return;
            if (!confirm("Are you sure you want to permanently delete this run? This cannot be undone.")) return;

            try {
                await deleteDoc(doc(db, `categories/${categoryId}/subcategories/${subcategoryId}/runs`, runId));
                alert("Run deleted successfully.");
                router();
            } catch (error) {
                console.error("Failed to delete run:", error);
                alert("An error occurred while deleting the run.");
            }
        }

        const seedDatabase = async () => {
            console.log("This will POPULATE the 'categories' collection. It is critical that you MANUALLY delete the collection in the Firebase Console first for a clean seed.");
            if (!confirm("This will overwrite existing data. Are you sure you want to continue?")) return;

            const seedData = [
                { id: "96_exit", name: "96 Exit", order: 1, subcategories: [] },
                { id: "all_castles", name: "All Castles", order: 2, subcategories: [] },
                { id: "no_starworld", name: "No Starworld", order: 3, subcategories: [] },
                { id: "11_exit", name: "11 Exit", order: 4, subcategories: [
                    { id: 'cloud', name: 'Cloud', order: 1 },
                    { id: 'orb', name: 'Orb', order: 2 },
                    { id: 'glitchless', name: 'Glitchless', order: 3 },
                ]},
                { id: "0_exit", name: "0 Exit", order: 5, subcategories: [] },
                { id: "95_exit_no_cape", name: "95 Exit, No Cape", order: 6, subcategories: [] },
                { id: "all_castles_no_cape", name: "All Castles, No Cape", order: 7, subcategories: [] },
                { id: "no_cape_no_starworld", name: "No Cape, No Starworld", order: 8, subcategories: [] },
                { id: "11_exit_no_cape", name: "11 Exit, No Cape", order: 9, subcategories: [
                    { id: 'cloud', name: 'Cloud', order: 1 },
                    { id: 'orb', name: 'Orb', order: 2 },
                    { id: 'glitchless', name: 'Glitchless', order: 3 },
                ]},
                { id: "all_castles_small_only", name: "All Castles, Small Only", order: 10, subcategories: [] },
                { id: "no_starworld_small_only", name: "No Starworld, Small Only", order: 11, subcategories: [] },
                { id: "small_only", name: "Small Only", order: 12, subcategories: [] },
                { id: "lunar_dragon", name: "Lunar Dragon", order: 13, subcategories: [
                    { id: 'glitchless', name: 'Glitchless', order: 1 },
                    { id: 'glitches', name: 'Glitches', order: 2 },
                ]}
            ];
            
            try {
                console.log("Starting database seed...");
                const batch = writeBatch(db);
                for (const category of seedData) {
                    const categoryRef = doc(db, 'categories', category.id);
                    batch.set(categoryRef, { name: category.name, order: category.order });
                    if (category.subcategories.length > 0) {
                        for (const sub of category.subcategories) {
                            const subRef = doc(db, `categories/${category.id}/subcategories`, sub.id);
                            batch.set(subRef, { name: sub.name, order: sub.order });
                        }
                    } else {
                         const defaultSubRef = doc(db, `categories/${category.id}/subcategories`, 'default');
                         batch.set(defaultSubRef, { name: 'Default', order: 1 });
                    }
                }
                await batch.commit();
                console.log("DATABASE SEEDING COMPLETE!");
                window.location.reload();
            } catch (error) {
                console.error("SEEDING FAILED:", error);
                alert("Seeding failed. Check the console for details. Make sure the 'categories' collection was manually deleted from Firebase first.");
            }
        }
        
        // ==============================================================================
        // --- 6. INITIALIZATION & GLOBAL FUNCTIONS ---
        // ==============================================================================
        window.addEventListener('hashchange', router);
        document.addEventListener('DOMContentLoaded', () => {
            document.body.insertAdjacentHTML('beforeend', `
                <div id="submission-modal" class="modal">
                    <div class="modal-content">
                        <span class="close-btn" onclick="window.closeModal('submission-modal')">&times;</span>
                        <h2>Submit New Run</h2>
                        <form id="submission-form" onsubmit="window.handleRunSubmission(event)">
                            <label for="category-select">Category:</label><select id="category-select" required></select>
                            <div id="subcategory-group" style="display: none;"><label for="subcategory-select">Sub-category:</label><select id="subcategory-select" required></select></div>
                            <label for="runner">Runner:</label><input type="text" id="runner" required>
                            <label for="time">Time (e.g., 47:15 or 1:23:45):</label><input type="text" id="time" required>
                            <label for="date">Date:</label><input type="date" id="date" required>
                            <label for="videoLink">Video Link:</label><input type="url" id="videoLink" required>
                            <button type="submit" id="submit-run-button">Submit Run</button>
                        </form>
                    </div>
                </div>
                <div id="edit-run-modal" class="modal">
                    <div class="modal-content">
                        <span class="close-btn" onclick="window.closeModal('edit-run-modal')">&times;</span>
                        <h2>Edit Run</h2>
                        <form id="edit-run-form" onsubmit="window.handleRunUpdate(event)">
                            <input type="hidden" id="edit-run-id"><input type="hidden" id="edit-category-id"><input type="hidden" id="edit-subcategory-id">
                            <label for="edit-runner">Runner:</label><input type="text" id="edit-runner" required>
                            <label for="edit-time">Time:</label><input type="text" id="edit-time" required>
                            <label for="edit-date">Date:</label><input type="date" id="edit-date" required>
                            <label for="edit-videoLink">Video Link:</label><input type="url" id="edit-videoLink" required>
                            <button type="submit" id="update-run-button">Update Run</button>
                        </form>
                    </div>
                </div>
                 <div id="login-modal" class="modal">
                    <div class="modal-content">
                        <span class="close-btn" onclick="window.closeModal('login-modal')">&times;</span>
                        <h2>Moderator Login</h2>
                        <form id="login-form" onsubmit="window.handleLogin(event)">
                            <label for="email">Email:</label>
                            <input type="email" id="email" required>
                            <label for="password">Password:</label>
                            <input type="password" id="password" required>
                            <button type="submit">Log In</button>
                            <p id="login-error" class="error-message"></p>
                        </form>
                    </div>
                </div>
            `);
            
            // Attach functions to the window object to make them globally accessible from HTML
            Object.assign(window, {
                openSubmissionModal, openLoginModal, logoutModerator,
                openEditModal, deleteRun, updateRunStatus,
                seedDatabase, handleLogin, handleRunSubmission,
                handleRunUpdate, closeModal
            });
            
            onAuthStateChanged(auth, user => { updateModeratorUI(user); });
            router();
        });
    </script>
</body>
</html>
